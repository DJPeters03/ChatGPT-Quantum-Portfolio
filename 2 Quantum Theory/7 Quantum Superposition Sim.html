<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Quantum Demo — Superposition, Born Rule, Collapse (Teaching Tool)</title>
  <style>
    :root{ color-scheme: dark; }
    html,body{ height:100%; margin:0; background:#0b0f14; color:#e8eef6; }
    body{ font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    *{ box-sizing:border-box; }
    .wrap{ width:min(1250px, 96vw); margin:14px auto; display:grid; gap:12px; }
    .card{
      background:#0f1622; border:1px solid rgba(255,255,255,.10);
      border-radius:14px; padding:12px;
      box-shadow:0 10px 26px rgba(0,0,0,.25);
    }
    h1{ margin:0 0 8px 0; font-size:18px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .pill{
      display:flex; align-items:center; gap:8px;
      background:#0b0f14; border:1px solid rgba(255,255,255,.10);
      border-radius:999px; padding:8px 10px;
      font-size:13px; opacity:.95;
    }
    input[type="range"]{ width:220px; }
    button{
      background:#1a2636; border:1px solid rgba(255,255,255,.14);
      color:#e8eef6; padding:10px 12px; border-radius:12px;
      cursor:pointer; font-weight:900;
    }
    button:hover{ border-color: rgba(255,255,255,.25); }
    button:active{ transform: translateY(1px); }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; }
    .grid{
      display:grid; gap:12px;
      grid-template-columns: 1.1fr 0.9fr;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
    }
    .viz{
      padding:0; overflow:hidden;
    }
    .frame{ height:620px; width:100%; position:relative; }
    canvas{ width:100%; height:100%; display:block; }
    .small{
      font-size:13px; opacity:.88; line-height:1.45;
    }
    .kv{
      display:grid; grid-template-columns: 1fr 1fr;
      gap:6px 12px; margin-top:10px; font-size:13px;
    }
    .k{ opacity:.75; }
    .v{ font-weight:900; }
    .log{
      margin-top:10px;
      background:#0b0f14; border:1px solid rgba(255,255,255,.10);
      border-radius:14px; padding:10px;
    }
    .logTop{ display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .logList{
      margin-top:8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      font-size:13px; line-height:1.5;
      white-space:pre-wrap; word-break:break-word;
      max-height:190px; overflow:auto;
      padding:8px; border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.03);
    }
    .tag{
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14); font-size:12px; opacity:.9;
    }
    .warn{
      margin-top:10px; font-size:12.8px; opacity:.85;
      border-left:3px solid rgba(255,255,255,.22);
      padding-left:10px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Quantum Teaching Demo: Superposition → Measurement → Collapse (Z basis)</h1>
      <div class="row">
        <button id="measureBtn">Measure in Z (collapse)</button>
        <button id="measureManyBtn">Run 50 measurements</button>
        <button id="resetBtn">Reset to |0⟩</button>

        <div class="pill">
          θ (mix 0↔1)
          <input id="theta" type="range" min="0" max="180" step="1" value="60" />
          <span class="mono" id="thetaLabel">60°</span>
        </div>

        <div class="pill">
          φ (relative phase)
          <input id="phi" type="range" min="0" max="360" step="1" value="0" />
          <span class="mono" id="phiLabel">0°</span>
        </div>

        <div class="pill">
          Weakness (partial collapse)
          <input id="weak" type="range" min="0" max="100" step="1" value="100" />
          <span class="mono" id="weakLabel">100%</span>
        </div>

        <div class="pill">
          Auto precess
          <input id="auto" type="checkbox" />
          <span class="mono">φ +=</span>
          <input id="autoSpeed" type="range" min="0.0" max="3.0" step="0.01" value="0.6" />
          <span class="mono" id="autoSpeedLabel">0.60</span>
        </div>
      </div>

      <div class="warn small">
        <span class="tag">What this teaches</span>
        Superposition is the state <span class="mono">|ψ⟩ = cos(θ/2)|0⟩ + e^{iφ} sin(θ/2)|1⟩</span>.
        Measuring in the <b>Z basis</b> gives <span class="mono">0</span> with probability <span class="mono">cos²(θ/2)</span> and
        <span class="mono">1</span> with probability <span class="mono">sin²(θ/2)</span>. After measuring, the state collapses to <span class="mono">|0⟩</span> or <span class="mono">|1⟩</span>.
        (The φ phase does <b>not</b> change Z-measurement probabilities, which is an important lesson.)
      </div>
    </div>

    <div class="grid">
      <div class="card viz">
        <div class="frame" id="frame">
          <canvas id="c"></canvas>
        </div>
      </div>

      <div class="card">
        <div class="small">
          <b>How to teach with this:</b>
          <ul style="margin:8px 0 0 18px;">
            <li>Slide <span class="mono">θ</span>: watch probabilities shift from always-0 → 50/50 → always-1.</li>
            <li>Slide <span class="mono">φ</span>: show phase changes the <i>direction</i> on the Bloch disk but not Z outcomes.</li>
            <li>Click <b>Measure</b>: outcome is random with Born-rule probabilities; state collapses.</li>
            <li>Run many measurements: frequencies approach the predicted probabilities.</li>
            <li><span class="mono">Weakness</span> &lt; 100% demonstrates partial collapse (pedagogical “weak measurement”).</li>
          </ul>
        </div>

        <div class="kv">
          <div class="k">State</div><div class="v mono" id="stateHud">—</div>
          <div class="k">α amplitude (|0⟩)</div><div class="v mono" id="alphaHud">—</div>
          <div class="k">β amplitude (|1⟩)</div><div class="v mono" id="betaHud">—</div>
          <div class="k">P(0) in Z</div><div class="v mono" id="p0Hud">—</div>
          <div class="k">P(1) in Z</div><div class="v mono" id="p1Hud">—</div>
          <div class="k">Last measurement</div><div class="v mono" id="lastHud">—</div>
          <div class="k">Counts (0 / 1)</div><div class="v mono" id="countsHud">—</div>
        </div>

        <div class="log">
          <div class="logTop">
            <div>
              <b>Measurement log</b>
              <div class="small" style="opacity:.8;">(most recent on the right)</div>
            </div>
            <button id="clearBtn" style="padding:8px 10px; border-radius:10px;">Clear</button>
          </div>
          <div class="logList" id="log">—</div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const frame  = document.getElementById('frame');
  const ctx = canvas.getContext('2d');

  const thetaSl = document.getElementById('theta');
  const phiSl   = document.getElementById('phi');
  const weakSl  = document.getElementById('weak');
  const autoCb  = document.getElementById('auto');
  const autoSpeedSl = document.getElementById('autoSpeed');

  const thetaLabel = document.getElementById('thetaLabel');
  const phiLabel   = document.getElementById('phiLabel');
  const weakLabel  = document.getElementById('weakLabel');
  const autoSpeedLabel = document.getElementById('autoSpeedLabel');

  const measureBtn = document.getElementById('measureBtn');
  const measureManyBtn = document.getElementById('measureManyBtn');
  const resetBtn   = document.getElementById('resetBtn');
  const clearBtn   = document.getElementById('clearBtn');

  const stateHud = document.getElementById('stateHud');
  const alphaHud = document.getElementById('alphaHud');
  const betaHud  = document.getElementById('betaHud');
  const p0Hud    = document.getElementById('p0Hud');
  const p1Hud    = document.getElementById('p1Hud');
  const lastHud  = document.getElementById('lastHud');
  const countsHud= document.getElementById('countsHud');
  const logEl    = document.getElementById('log');

  // ---------- canvas sizing ----------
  let W=0,H=0,DPR=1,cx=0,cy=0;
  function resize(){
    const r = frame.getBoundingClientRect();
    DPR = Math.max(devicePixelRatio || 1, 1);
    canvas.width  = Math.floor(r.width * DPR);
    canvas.height = Math.floor(r.height * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    W = r.width; H = r.height;
    cx = W/2; cy = H/2;
  }
  new ResizeObserver(resize).observe(frame);
  resize();

  // ---------- math helpers ----------
  const TAU = Math.PI * 2;
  const clamp01 = x => Math.max(0, Math.min(1, x));
  const deg2rad = d => d * Math.PI / 180;
  const fmt = (x, n=3) => (Math.abs(x) < 1e-12 ? 0 : x).toFixed(n);

  // Complex numbers (tiny)
  function C(re, im){ return {re, im}; }
  function cMul(a,b){ return C(a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re); }
  function cAbs2(a){ return a.re*a.re + a.im*a.im; }
  function cExpI(phi){ return C(Math.cos(phi), Math.sin(phi)); } // e^{iφ}

  // ---------- quantum state ----------
  // State: |ψ> = α|0> + β|1>, normalized.
  let theta = deg2rad(Number(thetaSl.value));
  let phi   = deg2rad(Number(phiSl.value));
  let alpha = C(1,0);
  let beta  = C(0,0);

  function setFromAngles(){
    theta = deg2rad(Number(thetaSl.value));
    phi   = deg2rad(Number(phiSl.value));
    const a = Math.cos(theta/2);
    const b = Math.sin(theta/2);
    alpha = C(a, 0);
    beta  = cMul(cExpI(phi), C(b, 0));
  }

  function anglesFromState(){
    // For teaching: track theta and phi from current state (assuming normalized).
    // theta from |beta|^2 = sin^2(theta/2)
    const p1 = clamp01(cAbs2(beta));
    const th = 2 * Math.asin(Math.sqrt(p1));
    // phi from argument of beta (if beta ~ 0, keep current)
    let ph = phi;
    if (Math.sqrt(p1) > 1e-6){
      ph = Math.atan2(beta.im, beta.re);
      if (ph < 0) ph += TAU;
    }
    theta = th; phi = ph;
    thetaSl.value = String(Math.round(theta * 180/Math.PI));
    phiSl.value   = String(Math.round(phi   * 180/Math.PI));
    thetaLabel.textContent = `${thetaSl.value}°`;
    phiLabel.textContent   = `${phiSl.value}°`;
  }

  // ---------- measurement / collapse ----------
  let count0 = 0, count1 = 0;
  const log = [];
  const LOG_MAX = 300;
  let lastMeas = "—";

  function updateUI(){
    const p0 = clamp01(cAbs2(alpha));
    const p1 = clamp01(cAbs2(beta));

    // compact state string (not too mathy)
    const aStr = `${fmt(alpha.re,3)}${alpha.im>=0?"+":"-"}${fmt(Math.abs(alpha.im),3)}i`;
    const bStr = `${fmt(beta.re,3)}${beta.im>=0?"+":"-"}${fmt(Math.abs(beta.im),3)}i`;

    stateHud.textContent = `|ψ⟩ = α|0⟩ + β|1⟩`;
    alphaHud.textContent = `α = ${aStr}`;
    betaHud.textContent  = `β = ${bStr}`;
    p0Hud.textContent    = `P(0)=|α|²=${p0.toFixed(3)}`;
    p1Hud.textContent    = `P(1)=|β|²=${p1.toFixed(3)}`;
    lastHud.textContent  = lastMeas;
    countsHud.textContent= `${count0} / ${count1}`;
    logEl.textContent    = log.length ? log.join(" ") : "—";
    logEl.scrollTop = logEl.scrollHeight;

    thetaLabel.textContent = `${thetaSl.value}°`;
    phiLabel.textContent   = `${phiSl.value}°`;
    weakLabel.textContent  = `${weakSl.value}%`;
    autoSpeedLabel.textContent = Number(autoSpeedSl.value).toFixed(2);
  }

  function measureZ(){
    // Born rule:
    const p0 = clamp01(cAbs2(alpha));
    const r = Math.random();
    const outcome = (r < p0) ? 0 : 1;

    // Pedagogical partial collapse (weak measurement):
    // weakness=100% => full collapse to eigenstate
    // weakness<100% => move state partially toward the eigenstate then renormalize
    const w = clamp01(Number(weakSl.value)/100);

    // target eigenstates: |0>=(1,0), |1>=(0,1)
    const targA = (outcome === 0) ? C(1,0) : C(0,0);
    const targB = (outcome === 0) ? C(0,0) : C(1,0);

    // interpolate in amplitude space then renormalize
    alpha = C(alpha.re*(1-w) + targA.re*w, alpha.im*(1-w) + targA.im*w);
    beta  = C(beta.re *(1-w) + targB.re*w, beta.im *(1-w) + targB.im*w);

    // renormalize
    const norm2 = cAbs2(alpha) + cAbs2(beta);
    const inv = 1/Math.sqrt(Math.max(norm2, 1e-12));
    alpha = C(alpha.re*inv, alpha.im*inv);
    beta  = C(beta.re*inv,  beta.im*inv);

    // update angles sliders to reflect new state
    anglesFromState();

    // log
    lastMeas = `Z measurement → ${outcome}  (random, P(0)=|α|²)`;
    log.push(String(outcome));
    if (log.length > LOG_MAX) log.shift();
    if (outcome === 0) count0++; else count1++;

    updateUI();
    // flash effect
    flash(outcome);
  }

  function reset(){
    thetaSl.value = "0";
    phiSl.value = "0";
    weakSl.value = "100";
    setFromAngles();
    count0=0; count1=0;
    log.length=0;
    lastMeas="—";
    updateUI();
  }

  function clearLog(){
    count0=0; count1=0;
    log.length=0;
    lastMeas="—";
    updateUI();
  }

  // ---------- drawing (Bloch disk + amplitudes + collapse animation) ----------
  let flashUntil = 0;
  let flashOutcome = 0;
  function flash(outcome){
    flashOutcome = outcome;
    flashUntil = performance.now() + 220;
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // Layout: Left = Bloch disk, Right = bars + labels
    const pad = 22;
    const diskR = Math.min(W, H) * 0.28;
    const diskCx = Math.max(pad + diskR, W*0.38);
    const diskCy = H*0.46;

    // compute Bloch vector (for pure state):
    // For |ψ>=cos(θ/2)|0> + e^{iφ} sin(θ/2)|1>
    // Bloch coords: x = sinθ cosφ, y = sinθ sinφ, z = cosθ
    const th = deg2rad(Number(thetaSl.value));
    const ph = deg2rad(Number(phiSl.value));
    const x = Math.sin(th)*Math.cos(ph);
    const y = Math.sin(th)*Math.sin(ph);
    const z = Math.cos(th);

    // disk shows x-y plane; z shown separately
    ctx.save();

    // Disk background
    ctx.beginPath();
    ctx.arc(diskCx, diskCy, diskR, 0, TAU);
    ctx.fillStyle = "rgba(255,255,255,.03)";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(255,255,255,.22)";
    ctx.stroke();

    // Axes
    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(diskCx - diskR, diskCy);
    ctx.lineTo(diskCx + diskR, diskCy);
    ctx.moveTo(diskCx, diskCy - diskR);
    ctx.lineTo(diskCx, diskCy + diskR);
    ctx.stroke();

    // Labels
    ctx.fillStyle = "rgba(255,255,255,.85)";
    ctx.font = "bold 14px ui-monospace, Menlo, monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("+X", diskCx + diskR + 26, diskCy);
    ctx.fillText("-X", diskCx - diskR - 26, diskCy);
    ctx.fillText("+Y", diskCx, diskCy - diskR - 24);
    ctx.fillText("-Y", diskCx, diskCy + diskR + 24);

    // State point on disk
    const px = diskCx + x * diskR;
    const py = diskCy - y * diskR; // screen y flips

    // phase ring trail (just a nice visual)
    ctx.beginPath();
    ctx.arc(diskCx, diskCy, diskR*0.78, 0, TAU);
    ctx.strokeStyle = "rgba(255,255,255,.06)";
    ctx.lineWidth = 10;
    ctx.stroke();

    // point halo
    ctx.beginPath();
    ctx.arc(px, py, 18, 0, TAU);
    ctx.fillStyle = "rgba(255,255,255,.10)";
    ctx.fill();

    // point
    ctx.beginPath();
    ctx.arc(px, py, 8.5, 0, TAU);
    ctx.fillStyle = "rgba(255,255,255,.95)";
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(0,0,0,.35)";
    ctx.stroke();

    // vector line
    ctx.strokeStyle = "rgba(255,255,255,.20)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(diskCx, diskCy);
    ctx.lineTo(px, py);
    ctx.stroke();

    // Z meter on the right of disk
    const meterX = diskCx + diskR + 95;
    const meterY = diskCy - diskR;
    const meterH = diskR*2;
    const meterW = 18;

    // meter outline
    ctx.strokeStyle = "rgba(255,255,255,.22)";
    ctx.lineWidth = 2;
    ctx.strokeRect(meterX, meterY, meterW, meterH);

    // z fill (top is +1)
    const zNorm = (z + 1)/2; // 0..1
    const fillH = zNorm * meterH;
    ctx.fillStyle = "rgba(255,255,255,.14)";
    ctx.fillRect(meterX, meterY + (meterH - fillH), meterW, fillH);

    ctx.fillStyle = "rgba(255,255,255,.85)";
    ctx.font = "bold 13px ui-monospace, Menlo, monospace";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.fillText("Z", meterX + meterW + 10, meterY + meterH/2);
    ctx.fillText("+1", meterX - 2, meterY - 10);
    ctx.fillText("-1", meterX - 2, meterY + meterH + 12);

    // Bars for probabilities (Born rule)
    const p0 = clamp01(cAbs2(alpha));
    const p1 = clamp01(cAbs2(beta));

    const barsX = pad;
    const barsY = pad;
    const barsW = Math.min(W - pad*2, diskCx - diskR - pad*1.2);
    const barH  = 22;

    function drawBar(label, p, y){
      ctx.fillStyle = "rgba(255,255,255,.10)";
      ctx.fillRect(barsX, y, barsW, barH);
      ctx.fillStyle = "rgba(255,255,255,.35)";
      ctx.fillRect(barsX, y, barsW*p, barH);
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.strokeRect(barsX, y, barsW, barH);

      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = "bold 14px ui-monospace, Menlo, monospace";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText(`${label}  ${p.toFixed(3)}`, barsX + 8, y + barH/2);
    }

    drawBar("P(0)=|α|²", p0, barsY);
    drawBar("P(1)=|β|²", p1, barsY + 32);

    // Display the superposition equation
    ctx.fillStyle = "rgba(255,255,255,.86)";
    ctx.font = "bold 14px ui-monospace, Menlo, monospace";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    const eqX = barsX;
    const eqY = barsY + 70;
    ctx.fillText(`|ψ⟩ = cos(θ/2)|0⟩ + e^{iφ} sin(θ/2)|1⟩`, eqX, eqY);
    ctx.fillText(`θ=${Number(thetaSl.value)}°   φ=${Number(phiSl.value)}°`, eqX, eqY + 20);

    // Flash overlay on measurement (green for 0, orange for 1)
    const now = performance.now();
    if (now < flashUntil){
      const t = (flashUntil - now)/220;
      ctx.globalAlpha = 0.18 * t;
      ctx.fillStyle = (flashOutcome === 0) ? "#2ecc71" : "#f39c12";
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;
    }

    // Instruction footer
    ctx.fillStyle = "rgba(255,255,255,.70)";
    ctx.font = "12.5px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
    ctx.textAlign = "left";
    ctx.textBaseline = "bottom";
    ctx.fillText("Tip: set θ=90° for a 50/50 superposition in Z. Change φ to show phase doesn’t affect Z outcomes.", pad, H - 12);

    ctx.restore();
  }

  // ---------- events ----------
  thetaSl.addEventListener('input', () => { setFromAngles(); updateUI(); });
  phiSl.addEventListener('input',   () => { setFromAngles(); updateUI(); });
  weakSl.addEventListener('input',  () => { updateUI(); });

  measureBtn.addEventListener('click', () => measureZ());
  measureManyBtn.addEventListener('click', () => {
    // run quickly but still show a couple flashes
    for (let i=0;i<50;i++) measureZ();
  });
  resetBtn.addEventListener('click', reset);
  clearBtn.addEventListener('click', clearLog);

  // init
  setFromAngles();
  updateUI();

  // ---------- loop (auto phase precession) ----------
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;

    if (autoCb.checked){
      const sp = Number(autoSpeedSl.value);
      let phiDeg = Number(phiSl.value);
      phiDeg = (phiDeg + sp * 60 * dt) % 360; // convert to friendly speed
      phiSl.value = String(phiDeg);
      setFromAngles();
      updateUI();
    }

    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>